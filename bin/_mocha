#!/usr/bin/env node
'use strict';

/* eslint no-unused-vars: off */

/**
 * Module dependencies.
 */

const yargs = require('yargs');
const path = require('path');
const minimatch = require('minimatch');
const fs = require('fs');
const debug = require('debug')('mocha:cli');
const Mocha = require('../');
const getOptions = require('./options');
const {loadConfig} = require('../lib/config');
const utils = Mocha.utils;
const join = path.join;
const cwd = process.cwd();
const mocha = new Mocha();

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

const Date = global.Date;
const setTimeout = global.setTimeout;
const setInterval = global.setInterval;
const clearTimeout = global.clearTimeout;
const clearInterval = global.clearInterval;

/**
 * Exits Mocha when tests + code under test has finished execution (default)
 * @param {number} code - Exit code; typically # of failures
 */
const exitLater = code => {
  process.on('exit', () => {
    process.exit(Math.min(code, 255));
  });
};

/**
 * Exits Mocha when Mocha itself has finished execution, regardless of
 * what the tests or code under test is doing.
 * @param {number} code - Exit code; typically # of failures
 */
const exit = code => {
  const clampedCode = Math.min(code, 255);
  let draining = 0;

  // Eagerly set the process's exit code in case stream.write doesn't
  // execute its callback before the process terminates.
  process.exitCode = clampedCode;

  // flush output for Node.js Windows pipe bug
  // https://github.com/joyent/node/issues/6247 is just one bug example
  // https://github.com/visionmedia/mocha/issues/333 has a good discussion
  const done = () => {
    if (!draining--) {
      process.exit(clampedCode);
    }
  };

  const streams = [process.stdout, process.stderr];

  streams.forEach(stream => {
    // submit empty write request and wait for completion
    draining += 1;
    stream.write('', done);
  });

  done();
};

/**
 * Parse list.
 */
const list = str =>
  Array.isArray(str) ? list(str.join(',')) : (str || '').split(/ *, */);

/**
 * Parse multiple flag.
 */
const collect = (val, memo) => memo.concat(val);

/**
 * Hide the cursor.
 */
const hideCursor = () => {
  process.stdout.write('\u001b[?25l');
};

/**
 * Show the cursor.
 */
const showCursor = () => {
  process.stdout.write('\u001b[?25h');
};

/**
 * Stop.
 */
const stop = () => {
  process.stdout.write('\u001b[2K');
};

const listKeys = obj => {
  console.log();
  Object.keys(obj)
    .filter(value => /^[a-z]/.test(value))
    .sort()
    .forEach(key => {
      console.log(`    ${key}`);
    });
  console.log();
};

const runListInterfaces = () => {
  listKeys(Mocha.interfaces);
};

const runListReporters = () => {
  listKeys(Mocha.reporters);
};

const handleExtensions = argv => {
  const compilers = argv.compilers || [];
  if (compilers.length) {
    require('util').deprecate(() => {},
    '"--compilers" will be removed in a future version of Mocha; see https://git.io/vdcSr for more info')();
  }

  argv.extensions = ['js'];
  compilers.forEach(c => {
    const idx = c.indexOf(':');
    const ext = c.slice(0, idx);
    let mod = c.slice(idx + 1);

    if (mod[0] === '.') {
      mod = join(process.cwd(), mod);
    }
    require(mod);
    argv.extensions.push(ext);
    argv.watchExtensions.push(ext);
  });
};

const handleRequires = argv => {
  (argv.require || []).forEach(mod => {
    try {
      require(mod);
    } catch (err) {
      if (err.code === 'MODULE_NOT_FOUND') {
        try {
          require(path.resolve(mod));
        } catch (ignored) {
          throw err;
        }
      } else {
        throw err;
      }
    }
  });
};

const handleFiles = argv => {
  let files = [];
  argv.spec.forEach(arg => {
    let newFiles;
    try {
      newFiles = utils.lookupFiles(arg, argv.extensions, argv.recursive);
    } catch (err) {
      if (err.message.indexOf('cannot resolve path') === 0) {
        console.error(
          `Warning: Could not find any test files matching pattern: ${arg}`
        );
        return;
      }

      throw err;
    }

    if (typeof newFiles !== 'undefined') {
      if (typeof newFiles === 'string') {
        newFiles = [newFiles];
      }
      newFiles = newFiles.filter(fileName =>
        (argv.exclude || []).every(pattern => !minimatch(fileName, pattern))
      );
    }

    files = files.concat(newFiles);
  });

  if (!files.length) {
    console.error('No test files found');
    process.exit(1);
  }

  const fileArgs = (argv.file || []).map(filepath => path.resolve(filepath));
  files = files.map(filepath => path.resolve(filepath));

  // ensure we don't sort the stuff from fileArgs; order is important!
  if (argv.sort) {
    files.sort();
  }

  // add files given through --file to be ran first
  files = fileArgs.concat(files);
  return files;
};

const runMocha = (argv, files) => {
  let runner;

  if (argv.watch) {
    console.log();
    hideCursor();
    process.on('SIGINT', () => {
      showCursor();
      console.log('\n');
      process.exit(130);
    });

    const watchFiles = utils.files(cwd, argv.watchExtensions);
    let runAgain = false;

    const loadAndRun = () => {
      try {
        mocha.files = files;
        runAgain = false;
        runner = mocha.run(() => {
          runner = null;
          if (runAgain) {
            rerun();
          }
        });
      } catch (e) {
        console.log(e.stack);
      }
    };

    const purge = () => {
      watchFiles.forEach(file => {
        delete require.cache[file];
      });
    };

    loadAndRun();

    const rerun = () => {
      purge();
      stop();
      if (!argv.grep) {
        mocha.grep(null);
      }
      mocha.suite = mocha.suite.clone();
      mocha.suite.ctx = new Mocha.Context();
      mocha.ui(argv.ui);
      loadAndRun();
    };

    utils.watch(watchFiles, () => {
      runAgain = true;
      if (runner) {
        runner.abort();
      } else {
        rerun();
      }
    });
  } else {
    // load
    mocha.files = files;
    runner = mocha.run(argv.exit ? exit : exitLater);
  }

  process.on('SIGINT', () => {
    runner.abort();

    // This is a hack:
    // Instead of `process.exit(130)`, set runner.failures to 130 (exit code for SIGINT)
    // The amount of failures will be emitted as error code later
    runner.failures = 130;
  });
};

const GROUPS = {
  FILES: 'File Handling',
  FILTERS: 'Test Filters & Sorting',
  NODEJS: 'Node.js & V8',
  OUTPUT: 'Reporting & Output',
  RULES: 'Rules & Behavior'
};

module.paths.push(cwd, join(cwd, 'node_modules'));

// If not already done, load mocha.opts
if (!process.env.LOADED_MOCHA_OPTS) {
  getOptions();
}

Error.stackTraceLimit = Infinity; // TODO: config

yargs
  .scriptName('mocha')
  .usage(
    '$0 [spec..]',
    'run Mocha tests',
    builder =>
      builder
        .options({
          'async-only': {
            alias: 'A',
            description:
              'require all tests to use a callback (async) or return a Promise',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          colors: {
            alias: 'c',
            description: 'force-enable color output',
            type: 'boolean',
            conflicts: ['no-colors'],
            group: GROUPS.OUTPUT
          },
          'no-colors': {
            alias: 'C',
            description: 'disable color output',
            type: 'boolean',
            conflicts: ['colors'],
            group: GROUPS.OUTPUT
          },
          growl: {
            alias: 'G',
            description: 'enable Growl notifications',
            type: 'boolean',
            default: false,
            group: GROUPS.OUTPUT
          },
          'reporter-options': {
            alias: 'O',
            description: 'reporter-specific options (<k=v,[k1=v1,..]>)',
            requiresArg: true,
            type: 'string',
            coerce: (opts = '') =>
              opts.split(',').reduce((acc, opt) => {
                const pair = opt.split('=');
                if (pair.length > 2 || !pair.length) {
                  throw new Error(`invalid reporter option '${opt}'`);
                }
                acc[pair[0]] = pair.length === 2 ? pair[1] : true;
                return acc;
              }, {}),
            group: GROUPS.OUTPUT
          },
          reporter: {
            alias: 'R',
            default: 'spec',
            type: 'string',
            requiresArg: true,
            nargs: 1,
            description: 'specify reporter to use',
            group: GROUPS.OUTPUT
          },
          sort: {
            alias: 'S',
            description: 'sort test files',
            type: 'boolean',
            default: false,
            group: GROUPS.FILTERS
          },
          bail: {
            alias: 'b',
            description: 'abort ("bail") after first test failure',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          debug: {
            alias: 'd',
            description: 'invoke node debugger; same as `node --debug`',
            type: 'boolean',
            hidden: true
          },
          grep: {
            alias: 'g',
            description: 'only run tests matching this regular expression',
            requiresArg: true,
            type: 'string',
            coerce: value => (!value ? null : value),
            group: GROUPS.FILTERS
          },
          fgrep: {
            alias: 'f',
            description: 'only run tests containing this string',
            requiresArg: true,
            type: 'string',
            group: GROUPS.FILTERS
          },
          'expose-gc': {
            alias: 'gc',
            description: 'equivalent to node flag `--expose-gc`',
            type: 'boolean',
            hidden: true
          },
          invert: {
            alias: 'i',
            description: 'inverts --grep and --fgrep matches',
            type: 'boolean',
            default: false,
            check: argv => {
              if (!('fgrep' in argv) || !('grep' in argv)) {
                throw new Error('`invert` requires one of `fgrep` or `grep`');
              }
              return true;
            },
            group: GROUPS.FILTERS
          },
          require: {
            alias: 'r',
            description: 'require specified module',
            type: 'array',
            requiresArg: true,
            group: GROUPS.FILES
          },
          slow: {
            alias: 's',
            description: 'specify "slow" test threshold in milliseconds',
            type: 'number',
            default: 75,
            group: GROUPS.RULES
          },
          timeout: {
            alias: 't',
            description: 'specify test timeout threshold in milliseconds',
            default: 2000,
            group: GROUPS.RULES
          },
          ui: {
            alias: 'u',
            default: 'bdd',
            type: 'string',
            requiresArg: true,
            description: 'specify user interface',
            group: GROUPS.RULES
          },
          watch: {
            alias: 'w',
            type: 'boolean',
            description:
              'watch files in the current working directory for changes',
            default: false,
            group: GROUPS.FILES
          },
          'check-leaks': {
            description: 'check for global variable leaks',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          'full-trace': {
            description: 'display full stack traces',
            type: 'boolean',
            default: false,
            group: GROUPS.OUTPUT
          },
          compilers: {
            description:
              'use the given module(s) to compile files (<ext:module,[ext1:module1]>)',
            type: 'string',
            coerce: (opts = '') => opts.split(','),
            group: GROUPS.FILES
          },
          globals: {
            description: 'comma-separated list of allowed global variables',
            type: 'string',
            coerce: list,
            requiresArg: true,
            group: GROUPS.RULES
          },
          'inline-diffs': {
            description:
              'display actual/expected differences inline within each string',
            type: 'boolean',
            default: false,
            group: GROUPS.OUTPUT
          },
          diff: {
            description: 'show diff on failure',
            type: 'boolean',
            default: true,
            group: GROUPS.OUTPUT
          },
          exit: {
            description: 'force Mocha to quit after tests complete',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          'no-timeouts': {
            description: 'disable timeouts',
            type: 'boolean',
            conflicts: ['timeout'],
            group: GROUPS.RULES
          },
          opts: {
            description: 'path to `mocha.opts`',
            normalize: true,
            requiresArg: true,
            default: './test/mocha.opts'
          },
          recursive: {
            description: 'look for tests in subdirectories',
            type: 'boolean',
            default: false,
            group: GROUPS.FILES
          },
          retries: {
            description: 'retry failed tests <n> times',
            type: 'number',
            group: GROUPS.RULES
          },
          'watch-extensions': {
            description:
              'comma-separated list of extensions to monitor with `--watch`',
            type: 'string',
            coerce: list,
            default: 'js',
            requiresArg: true,
            group: GROUPS.FILES
          },
          delay: {
            description: 'delay initial execution of root suite',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          'allow-uncaught': {
            description: 'allow uncaught errors to propagate',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          'forbid-only': {
            description: 'presence of exclusive test(s) implies failure',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          'forbid-pending': {
            description: 'presence of pending test(s) implies failure',
            type: 'boolean',
            default: false,
            group: GROUPS.RULES
          },
          file: {
            description:
              'specify file(s) to be loaded prior to root suite execution',
            type: 'string',
            normalize: true,
            coerce: collect,
            requiresArg: true,
            group: GROUPS.FILES
          },
          exclude: {
            description: 'ignore file(s) or glob pattern(s)',
            type: 'string',
            coerce: collect,
            requiresArg: true,
            group: GROUPS.FILES
          },
          reporters: {
            description: 'list built-in reporters & exit',
            type: 'boolean'
          },
          interfaces: {
            description: 'list built-in user interfaces & exit',
            type: 'boolean'
          }
        })
        .positional('spec', {
          description: 'one or more files, directories, or globs to test',
          type: 'array',
          default: ['test/']
        })
        .showHidden(
          'show-node-options',
          'Show supported Node.js & V8 options; use with "--help"'
        )
        .pkgConf('mocha'),
    argv => {
      if (argv.interfaces) {
        runListInterfaces();
        process.exit();
      }
      if (argv.reporters) {
        runListReporters();
        process.exit();
      }

      mocha
        .fgrep(argv.fgrep)
        .globals(argv.globals)
        .grep(argv.grep)
        .reporter(argv.reporter, argv.reporterOptions)
        .retries(argv.retries)
        .ui(argv.ui)
        .useColors(argv.colors)
        .useInlineDiffs(argv.inlineDiffs);

      // inverted options
      mocha.hideDiff(!argv.diff).enableTimeouts(!argv.noTimeouts);

      // toggles not accepting parameters
      [
        'allowUncaught',
        'asyncOnly',
        'checkLeaks',
        'delay',
        'forbidOnly',
        'forbidPending',
        'fullTrace',
        'growl',
        'invert'
      ].forEach(arg => {
        if (argv[arg]) {
          mocha[arg]();
        }
      });

      mocha.suite
        .bail(argv.bail)
        .slow(argv.slow)
        .timeout(argv.timeout);

      handleExtensions(argv);
      handleRequires(argv);
      debug('running Mocha with args', argv);
      runMocha(argv, handleFiles(argv));
    }
  )
  .command(
    'init <path>',
    'create a client-side Mocha setup at <path>',
    builder =>
      builder.positional('path', {
        type: 'string',
        normalize: true
      }),
    argv => {
      const dest = argv.path;
      const mkdir = require('mkdirp');
      mkdir.sync(dest);
      const css = fs.readFileSync(path.join(__dirname, '..', 'mocha.css'));
      const js = fs.readFileSync(path.join(__dirname, '..', 'mocha.js'));
      const tmpl = fs.readFileSync(
        path.join(__dirname, '..', 'lib/template.html')
      );
      fs.writeFileSync(path.join(dest, 'mocha.css'), css);
      fs.writeFileSync(path.join(dest, 'mocha.js'), js);
      fs.writeFileSync(path.join(dest, 'tests.js'), '');
      fs.writeFileSync(path.join(dest, 'index.html'), tmpl);
      process.exit();
    }
  )
  .config(loadConfig(cwd))
  .parse();
